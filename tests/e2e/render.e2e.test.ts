/**
 * E2E Tests for VNTANA Render Operations
 *
 * Note: Renders can be:
 * 1. Auto-generated by VNTANA (still images, turntables)
 * 2. Manually uploaded via the resource/sign-url endpoint with storeType: 'RENDER'
 *
 * Accepted file types for RENDER uploads: jpeg, jpg, png, bmp, gif, tiff, svg, mp4, tif, mov, avi, pdf
 * Note: WebP is NOT supported for render uploads (storeType: 'RENDER'),
 *       but IS supported for attachments (storeType: 'ATTACHMENT') and product assets.
 */
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { getTestConfig, shouldSkipE2E, TestConfig } from './setup';
import { VntanaTestClient, createTestClient } from './helpers/testClient';
import { getTestPng } from '../fixtures/binary';

describe('Render E2E', () => {
	let config: TestConfig;
	let client: VntanaTestClient;
	let testProduct: { uuid: string; clientUuid: string } | null = null;
	let productWithRenders: { uuid: string; clientUuid: string } | null = null;
	let createdProductUuids: string[] = [];

	beforeAll(async () => {
		if (shouldSkipE2E()) {
			return;
		}
		config = getTestConfig();
		client = createTestClient(config);

		// Try to create a test product for upload tests, fall back to existing
		const response = await client.createProduct({
			name: `Render Test Product ${Date.now()}`,
			assetType: 'IMAGE',
			description: 'Product for render E2E tests',
		});

		if (response.success) {
			testProduct = { uuid: response.response.uuid, clientUuid: config.workspaceUuid };
			createdProductUuids.push(testProduct.uuid);
		} else {
			// Fall back to existing product or find one
			if (config.existingProductUuid) {
				testProduct = { uuid: config.existingProductUuid, clientUuid: config.workspaceUuid };
			} else {
				testProduct = await client.findExistingProduct();
			}
			if (testProduct) {
				console.log('Using existing product for render upload tests:', testProduct.uuid);
			}
		}

		// Find a product with existing renders for download tests
		productWithRenders = await client.findProductWithRenders();
		if (productWithRenders) {
			console.log('Found product with renders for download tests:', productWithRenders.uuid);
		}
	});

	afterAll(async () => {
		// Cleanup created products
		if (client && createdProductUuids.length > 0) {
			for (const uuid of createdProductUuids) {
				try {
					await client.deleteProduct(uuid);
				} catch (error) {
					console.warn(`Failed to cleanup product ${uuid}:`, error);
				}
			}
		}
		if (client) {
			client.clearTokenCache();
		}
	});

	describe('Upload Render', () => {
		it.skipIf(shouldSkipE2E())('should upload a render image to a product', async () => {
			if (!testProduct) {
				console.log('Render upload test skipped - test product not created (API may not support create)');
				return;
			}

			// Step 1: Get signed URL for render upload
			const pngBuffer = getTestPng();
			const signedUrlResponse = await client.getResourceUploadSignedUrl(
				testProduct.uuid,
				'test-render.png',
				pngBuffer.length,
				'image/png',
				'RENDER',
				testProduct.clientUuid,
			);

			if (!signedUrlResponse.success) {
				const errorMsg = signedUrlResponse.errors?.[0];
				console.log('Signed URL request failed:', typeof errorMsg === 'string' ? errorMsg : errorMsg?.message || JSON.stringify(signedUrlResponse.errors));
				console.log('Write operations may not be available for this account');
				return;
			}

			expect(signedUrlResponse.response.location).toBeDefined();
			expect(signedUrlResponse.response.blobId).toBeDefined();
			expect(signedUrlResponse.response.requestUuid).toBeDefined();

			// Step 2: Upload to signed URL
			await client.uploadToSignedUrl(
				signedUrlResponse.response.location,
				pngBuffer,
				'image/png',
			);

			// Verify upload completed (no error thrown)
		});
	});

	describe('Search Renders', () => {
		it.skipIf(shouldSkipE2E())('should search for renders on a product', async () => {
			if (!productWithRenders && !testProduct) {
				console.log('Render search test skipped - no product available');
				return;
			}

			const productToSearch = productWithRenders || testProduct!;

			// Search for attachments (renders are stored as attachments with entityType RENDER/TURNTABLE)
			const searchResponse = await client.searchAttachments(
				productToSearch.uuid,
				productToSearch.clientUuid,
			);

			expect(searchResponse.success).toBe(true);
			expect(searchResponse.response).toBeDefined();
			expect(searchResponse.response.grid).toBeInstanceOf(Array);

			// If we have a product with renders, verify we can find them
			if (productWithRenders) {
				const renders = searchResponse.response.grid.filter(
					(att: any) => att.entityType === 'RENDER' || att.entityType === 'TURNTABLE'
				);
				expect(renders.length).toBeGreaterThan(0);
				console.log(`Found ${renders.length} render(s) on product`);
			}
		});
	});

	describe('Download Render', () => {
		it.skipIf(shouldSkipE2E())('should download a render if one exists', async () => {
			if (!productWithRenders) {
				console.log('Render download test skipped - no product with renders found');
				console.log('To test render download, ensure there is a product with COMPLETED conversion');
				return;
			}

			// Search for renders on the product
			const searchResponse = await client.searchAttachments(
				productWithRenders.uuid,
				productWithRenders.clientUuid,
			);

			if (!searchResponse.success) {
				console.log('Failed to search attachments');
				return;
			}

			// Find a RENDER attachment (prefer PNG images over turntables)
			const renderAttachment = searchResponse.response.grid.find(
				(att: any) => att.entityType === 'RENDER',
			) || searchResponse.response.grid.find(
				(att: any) => att.entityType === 'TURNTABLE',
			);

			if (renderAttachment) {
				console.log(`Downloading render: ${renderAttachment.name} (${renderAttachment.entityType})`);

				// Download the render
				const buffer = await client.downloadAttachment(
					renderAttachment.blobId,
					productWithRenders.clientUuid,
				);

				expect(buffer).toBeInstanceOf(Buffer);
				expect(buffer.length).toBeGreaterThan(0);
				console.log(`Downloaded ${buffer.length} bytes`);
			} else {
				console.warn('No render attachment found to download');
			}
		});
	});
});
